
<library-reference>
  <section id="unordered.reference.specification">
    <!--
      Header: <boost/unordered_set.hpp>
      -->
    
    <header name="boost/unordered_set.hpp">
      <namespace name="boost">

        <!--
          boost::unordered_set
          -->
        
        <class name="unordered_set">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;Value&gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose>An unordered associative container that stores unique values.
          </purpose>
          <description>
            <para>For the normative reference see section 6.3 of 
              <ulink url="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">TR1 [n1836].
              </ulink>
            </para>
            <para>
              <emphasis role="bold">Template Parameters</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry>
                        <emphasis>Value</emphasis>
                      </entry>
                      <entry>Value must be Assignable and CopyConstructible
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Hash</emphasis>
                      </entry>
                      <entry>A unary function object type that acts a hash function for a 
                        <type>Value</type>. It takes a single argument of type 
                        <type>Value</type> and returns a value of type std::size_t.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Pred</emphasis>
                      </entry>
                      <entry>A binary function object that implements an equivalence relation on values of type 
                        <type>Value</type>. A binary function object that induces an equivalence relation on values of type Key. It takes two arguments of type Key and returns a value of type bool.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Alloc</emphasis>
                      </entry>
                      <entry>An allocator whose value type is the same as the container's value type.
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.
            </para>
            <para>The number of buckets is automatically increased whenever an insert will make the load factor greater than the maximum load factor. It can also change as result of calling rehash.
            </para>
            <para>When the number of buckets change: iterators are invalidated, the elements can change order, and move to different buckets, but pointers and references to elements remain valid.
            </para>
          </description>
          <typedef name="key_type">
            <type>Value</type>
          </typedef>
          <typedef name="value_type">
            <type>Value</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <description>
              <para>lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <description>
              <para>const lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>unsigned integral type
              <notes>
                <type>size_type</type> can represent any non-negative value of 
                <type>difference_type</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>signed integral type
              <notes>Is identical to the difference type of 
                <type>iterator</type> and 
                <type>const_iterator</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is 
                <type>value_type</type>.
              </para>
              <notes>
                <para>Any iterator category except output iterator.
                </para>
                <para>Convertible to 
                  <type>const_iterator</type>.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator whose value type is 
              <type>value_type</type>.
              <notes>
                <para>Any iterator category except output iterator.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>An iterator with the same value type, difference type and pointer and reference type as 
              <type>iterator</type>.
            </description>
            <description>A local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator with the same value type, difference type and pointer and reference type as 
              <type>const_iterator</type>.
            </description>
            <description>A const_local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <constructor>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <postconditions>
              <code><code><methodname>size</methodname>()</code> == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocatorand a maximum load factor of 1.0.
              </para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.
              </para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype><type>unordered_set</type> const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.
              </para>
            </description>
          </constructor>
          <destructor>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype><type>unordered_set</type> const&amp;</paramtype>
            </parameter>
            <type><type>unordered_set</type>&amp;</type>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><code><methodname>size</methodname>()</code> == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns>
                <code><methodname>size</methodname>()</code> of the largest possible container.
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="modifiers">
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype><type>value_type</type> const&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent value.
                </para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.
                </para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the elment with equivalent value.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="insert">
              <signature>
                <parameter name="hint">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="hint">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent value.
                </para>
                <para>hint is a suggestion to where the element should be inserted.
                </para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the elment with equivalent value.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. 
                </para>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </overloaded-method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent value.
                </para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="position">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="position">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Erase the element pointed to by 
                  <code>position</code>.
                </para>
              </description>
              <returns>
                <para>The iterator following 
                  <code>position</code> before the erasure.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>size_type</type>
              </signature>
              <description>
                <para>Erase all elements with key equivalent to 
                  <code>k</code>.
                </para>
              </description>
              <returns>
                <para>The number of elements erased.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="first">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="first">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <descritpion>
                <para>Erases the elements in the range from 
                  <code>first</code> to 
                  <code>last</code>.
                </para>
              </descritpion>
              <returns>
                <para>The iterator following the erased elements - i.e. 
                  <code>last</code>.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.
                </para>
              </description>
              <postconditions>
                <para>
                  <code><code><methodname>size</methodname>()</code> == 0</code>
                </para>
              </postconditions>
              <throws>
                <para>Never throws an exception.
                </para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype><type>unordered_set</type>&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
                  <type>key_equal</type> or 
                  <type>hasher</type>.
                </para>
              </throws>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to 
                  <code>k</code>, or 
                  <code>b.end()</code> if no such element exists.
                </para>
              </returns>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to 
                  <code>k</code>.
                </para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <returns>
                <para>A range with containing all elements with key equivalent to 
                  <code>k</code>. If the container doesn't container any such elements, returns 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.
                </para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.
                </para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para>
                  <code>n &lt; <methodname>bucket_count</methodname>()</code>
                </para>
              </requires>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key 
                  <code>k</code>.
                </para>
              </returns>
              <postconditions>
                <para>The return value is less than 
                  <code>bucket_count()</code>
                </para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.
                </para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.
                </para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>float</type>
              <returns>
                <para>Changes the container's maximum load factor,using 
                  <code>z</code> as a hint.
                </para>
              </returns>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least 
                  <code>n</code> buckets, and so that the load factor is less thanthe maximum load factor.
                </para>
                <para>Invalidates iterators, and changes the order of elements
                </para>
              </description>
              <throws>
                <para>The function has no effect if an exception is throw, unless it is thrown by the containerâ€™s hash function or comparison function.
                </para>
              </throws>
            </method>
          </method-group>
        </class>
        <function name="swap">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
            </template-type-parameter>
            <template-type-parameter name="Pred">
            </template-type-parameter>
            <template-type-parameter name="Alloc">
            </template-type-parameter>
          </template>
          <parameter name="x">
            <paramtype><type>unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <parameter name="y">
            <paramtype><type>unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <type>void</type>
          <effects>
            <para><code>x.swap(y)</code>
            </para>
          </effects>
          <throws>
            <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
              <code>Hash</code> or 
              <code>Pred</code>.
            </para>
          </throws>
        </function>

        <!--
          boost::unordered_multiset
          -->
        
        <class name="unordered_multiset">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;Value&gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose>An unordered associative container that stores  values. The same key can be stored multiple times. 
          </purpose>
          <description>
            <para>For the normative reference see section 6.3 of 
              <ulink url="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">TR1 [n1836].
              </ulink>
            </para>
            <para>
              <emphasis role="bold">Template Parameters</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry>
                        <emphasis>Value</emphasis>
                      </entry>
                      <entry>Value must be Assignable and CopyConstructible
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Hash</emphasis>
                      </entry>
                      <entry>A unary function object type that acts a hash function for a 
                        <type>Value</type>. It takes a single argument of type 
                        <type>Value</type> and returns a value of type std::size_t.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Pred</emphasis>
                      </entry>
                      <entry>A binary function object that implements an equivalence relation on values of type 
                        <type>Value</type>. A binary function object that induces an equivalence relation on values of type Key. It takes two arguments of type Key and returns a value of type bool.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Alloc</emphasis>
                      </entry>
                      <entry>An allocator whose value type is the same as the container's value type.
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.
            </para>
            <para>The number of buckets is automatically increased whenever an insert will make the load factor greater than the maximum load factor. It can also change as result of calling rehash.
            </para>
            <para>When the number of buckets change: iterators are invalidated, the elements can change order, and move to different buckets, but pointers and references to elements remain valid.
            </para>
          </description>
          <typedef name="key_type">
            <type>Value</type>
          </typedef>
          <typedef name="value_type">
            <type>Value</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <description>
              <para>lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <description>
              <para>const lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>unsigned integral type
              <notes>
                <type>size_type</type> can represent any non-negative value of 
                <type>difference_type</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>signed integral type
              <notes>Is identical to the difference type of 
                <type>iterator</type> and 
                <type>const_iterator</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A constant iterator whose value type is 
                <type>value_type</type>.
              </para>
              <notes>
                <para>Any iterator category except output iterator.
                </para>
                <para>Convertible to 
                  <type>const_iterator</type>.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator whose value type is 
              <type>value_type</type>.
              <notes>
                <para>Any iterator category except output iterator.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>An iterator with the same value type, difference type and pointer and reference type as 
              <type>iterator</type>.
            </description>
            <description>A local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator with the same value type, difference type and pointer and reference type as 
              <type>const_iterator</type>.
            </description>
            <description>A const_local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <constructor>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <postconditions>
              <code><code><methodname>size</methodname>()</code> == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocatorand a maximum load factor of 1.0.
              </para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.
              </para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype><type>unordered_multiset</type> const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.
              </para>
            </description>
          </constructor>
          <destructor>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype><type>unordered_multiset</type> const&amp;</paramtype>
            </parameter>
            <type><type>unordered_multiset</type>&amp;</type>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><code><methodname>size</methodname>()</code> == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns>
                <code><methodname>size</methodname>()</code> of the largest possible container.
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="modifiers">
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype><type>value_type</type> const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.
                </para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="insert">
              <signature>
                <parameter name="hint">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="hint">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Inserts obj in the container.
                </para>
                <para>hint is a suggestion to where the element should be inserted.
                </para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same value. 
                </para>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </overloaded-method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. 
                </para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="position">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="position">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Erase the element pointed to by 
                  <code>position</code>.
                </para>
              </description>
              <returns>
                <para>The iterator following 
                  <code>position</code> before the erasure.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>size_type</type>
              </signature>
              <description>
                <para>Erase all elements with key equivalent to 
                  <code>k</code>.
                </para>
              </description>
              <returns>
                <para>The number of elements erased.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="first">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="first">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <descritpion>
                <para>Erases the elements in the range from 
                  <code>first</code> to 
                  <code>last</code>.
                </para>
              </descritpion>
              <returns>
                <para>The iterator following the erased elements - i.e. 
                  <code>last</code>.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.
                </para>
              </description>
              <postconditions>
                <para>
                  <code><code><methodname>size</methodname>()</code> == 0</code>
                </para>
              </postconditions>
              <throws>
                <para>Never throws an exception.
                </para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype><type>unordered_multiset</type>&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
                  <type>key_equal</type> or 
                  <type>hasher</type>.
                </para>
              </throws>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to 
                  <code>k</code>, or 
                  <code>b.end()</code> if no such element exists.
                </para>
              </returns>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to 
                  <code>k</code>.
                </para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <returns>
                <para>A range with containing all elements with key equivalent to 
                  <code>k</code>. If the container doesn't container any such elements, returns 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.
                </para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.
                </para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para>
                  <code>n &lt; <methodname>bucket_count</methodname>()</code>
                </para>
              </requires>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key 
                  <code>k</code>.
                </para>
              </returns>
              <postconditions>
                <para>The return value is less than 
                  <code>bucket_count()</code>
                </para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.
                </para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.
                </para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>float</type>
              <returns>
                <para>Changes the container's maximum load factor,using 
                  <code>z</code> as a hint.
                </para>
              </returns>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least 
                  <code>n</code> buckets, and so that the load factor is less thanthe maximum load factor.
                </para>
                <para>Invalidates iterators, and changes the order of elements
                </para>
              </description>
              <throws>
                <para>The function has no effect if an exception is throw, unless it is thrown by the containerâ€™s hash function or comparison function.
                </para>
              </throws>
            </method>
          </method-group>
        </class>
        <function name="swap">
          <template>
            <template-type-parameter name="Value">
            </template-type-parameter>
            <template-type-parameter name="Hash">
            </template-type-parameter>
            <template-type-parameter name="Pred">
            </template-type-parameter>
            <template-type-parameter name="Alloc">
            </template-type-parameter>
          </template>
          <parameter name="x">
            <paramtype><type>unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <parameter name="y">
            <paramtype><type>unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <type>void</type>
          <effects>
            <para><code>x.swap(y)</code>
            </para>
          </effects>
          <throws>
            <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
              <code>Hash</code> or 
              <code>Pred</code>.
            </para>
          </throws>
        </function>
      </namespace>
    </header>
    <!--
      Header: <boost/unordered_map.hpp>
      -->
    
    <header name="boost/unordered_map.hpp">
      <namespace name="boost">

        <!--
          boost::unordered_map
          -->
        
        <class name="unordered_map">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="T">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose>An unordered associative container that associates unique keys with another value.
          </purpose>
          <description>
            <para>For the normative reference see section 6.3 of 
              <ulink url="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">TR1 [n1836].
              </ulink>
            </para>
            <para>
              <emphasis role="bold">Template Parameters</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry>
                        <emphasis>Key</emphasis>
                      </entry>
                      <entry>Key must be Assignable and CopyConstructible.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>T</emphasis>
                      </entry>
                      <entry>T must be CopyConstructible
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Hash</emphasis>
                      </entry>
                      <entry>A unary function object type that acts a hash function for a 
                        <type>Key</type>. It takes a single argument of type 
                        <type>Key</type> and returns a value of type std::size_t.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Pred</emphasis>
                      </entry>
                      <entry>A binary function object that implements an equivalence relation on values of type 
                        <type>Key</type>. A binary function object that induces an equivalence relation on values of type Key. It takes two arguments of type Key and returns a value of type bool.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Alloc</emphasis>
                      </entry>
                      <entry>An allocator whose value type is the same as the container's value type.
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.
            </para>
            <para>The number of buckets is automatically increased whenever an insert will make the load factor greater than the maximum load factor. It can also change as result of calling rehash.
            </para>
            <para>When the number of buckets change: iterators are invalidated, the elements can change order, and move to different buckets, but pointers and references to elements remain valid.
            </para>
          </description>
          <typedef name="key_type">
            <type>Key</type>
          </typedef>
          <typedef name="value_type">
            <type>std::pair&lt;Key const, Value&gt;</type>
          </typedef>
          <typedef name="mapped_type">
            <type>T</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <description>
              <para>lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <description>
              <para>const lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>unsigned integral type
              <notes>
                <type>size_type</type> can represent any non-negative value of 
                <type>difference_type</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>signed integral type
              <notes>Is identical to the difference type of 
                <type>iterator</type> and 
                <type>const_iterator</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A iterator whose value type is 
                <type>value_type</type>.
              </para>
              <notes>
                <para>Any iterator category except output iterator.
                </para>
                <para>Convertible to 
                  <type>const_iterator</type>.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator whose value type is 
              <type>value_type</type>.
              <notes>
                <para>Any iterator category except output iterator.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>An iterator with the same value type, difference type and pointer and reference type as 
              <type>iterator</type>.
            </description>
            <description>A local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator with the same value type, difference type and pointer and reference type as 
              <type>const_iterator</type>.
            </description>
            <description>A const_local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <constructor>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <postconditions>
              <code><code><methodname>size</methodname>()</code> == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocatorand a maximum load factor of 1.0.
              </para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.
              </para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype><type>unordered_map</type> const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.
              </para>
            </description>
          </constructor>
          <destructor>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype><type>unordered_map</type> const&amp;</paramtype>
            </parameter>
            <type><type>unordered_map</type>&amp;</type>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><code><methodname>size</methodname>()</code> == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns>
                <code><methodname>size</methodname>()</code> of the largest possible container.
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="modifiers">
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype><type>value_type</type> const&amp;</paramtype>
              </parameter>
              <type>std::pair&lt;iterator, bool&gt;</type>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent key.
                </para>
              </description>
              <returns>
                <para>The bool component of the return type is true if an insert took place.
                </para>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the elment with equivalent key.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="insert">
              <signature>
                <parameter name="hint">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="hint">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Inserts obj in the container if and only if there is no element in the container with an equivalent key.
                </para>
                <para>hint is a suggestion to where the element should be inserted.
                </para>
              </description>
              <returns>
                <para>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the elment with equivalent key.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. 
                </para>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </overloaded-method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.
                </para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="position">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="position">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Erase the element pointed to by 
                  <code>position</code>.
                </para>
              </description>
              <returns>
                <para>The iterator following 
                  <code>position</code> before the erasure.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>size_type</type>
              </signature>
              <description>
                <para>Erase all elements with key equivalent to 
                  <code>k</code>.
                </para>
              </description>
              <returns>
                <para>The number of elements erased.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="first">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="first">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <descritpion>
                <para>Erases the elements in the range from 
                  <code>first</code> to 
                  <code>last</code>.
                </para>
              </descritpion>
              <returns>
                <para>The iterator following the erased elements - i.e. 
                  <code>last</code>.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.
                </para>
              </description>
              <postconditions>
                <para>
                  <code><code><methodname>size</methodname>()</code> == 0</code>
                </para>
              </postconditions>
              <throws>
                <para>Never throws an exception.
                </para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype><type>unordered_map</type>&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
                  <type>key_equal</type> or 
                  <type>hasher</type>.
                </para>
              </throws>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to 
                  <code>k</code>, or 
                  <code>b.end()</code> if no such element exists.
                </para>
              </returns>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to 
                  <code>k</code>.
                </para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <returns>
                <para>A range with containing all elements with key equivalent to 
                  <code>k</code>. If the container doesn't container any such elements, returns 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                </para>
              </returns>
            </overloaded-method>
            <method name="operator[]">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type><type>mapped_type</type>&amp;</type>
              <effects>
                <para>If the container does not already contain an elements with a key equivalent to 
                  <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>
                </para>
              </effects>
              <returns>
                <para>A reference to <code>x.second</code> where x is the element already in the container, or the newly inserted element with a key equivalent to 
                  <code>k</code>
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.
                </para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.
                </para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para>
                  <code>n &lt; <methodname>bucket_count</methodname>()</code>
                </para>
              </requires>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key 
                  <code>k</code>.
                </para>
              </returns>
              <postconditions>
                <para>The return value is less than 
                  <code>bucket_count()</code>
                </para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.
                </para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.
                </para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>float</type>
              <returns>
                <para>Changes the container's maximum load factor,using 
                  <code>z</code> as a hint.
                </para>
              </returns>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least 
                  <code>n</code> buckets, and so that the load factor is less thanthe maximum load factor.
                </para>
                <para>Invalidates iterators, and changes the order of elements
                </para>
              </description>
              <throws>
                <para>The function has no effect if an exception is throw, unless it is thrown by the containerâ€™s hash function or comparison function.
                </para>
              </throws>
            </method>
          </method-group>
        </class>
        <function name="swap">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="T">
            </template-type-parameter>
            <template-type-parameter name="Hash">
            </template-type-parameter>
            <template-type-parameter name="Pred">
            </template-type-parameter>
            <template-type-parameter name="Alloc">
            </template-type-parameter>
          </template>
          <parameter name="x">
            <paramtype><type>unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <parameter name="y">
            <paramtype><type>unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <type>void</type>
          <effects>
            <para><code>x.swap(y)</code>
            </para>
          </effects>
          <throws>
            <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
              <code>Hash</code> or 
              <code>Pred</code>.
            </para>
          </throws>
        </function>

        <!--
          boost::unordered_multimap
          -->
        
        <class name="unordered_multimap">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="T">
            </template-type-parameter>
            <template-type-parameter name="Hash">
              <default><type>boost::hash&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Pred">
              <default><type>std::equal_to&lt;Value&gt;</type></default>
            </template-type-parameter>
            <template-type-parameter name="Alloc">
              <default><type>std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;</type></default>
            </template-type-parameter>
          </template>
          <purpose>An unordered associative container that associates  keys with another value. The same key can be stored multiple times. 
          </purpose>
          <description>
            <para>For the normative reference see section 6.3 of 
              <ulink url="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">TR1 [n1836].
              </ulink>
            </para>
            <para>
              <emphasis role="bold">Template Parameters</emphasis>
              <informaltable>
                <tgroup cols="2">
                  <tbody>
                    <row>
                      <entry>
                        <emphasis>Key</emphasis>
                      </entry>
                      <entry>Key must be Assignable and CopyConstructible.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>T</emphasis>
                      </entry>
                      <entry>T must be CopyConstructible
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Hash</emphasis>
                      </entry>
                      <entry>A unary function object type that acts a hash function for a 
                        <type>Key</type>. It takes a single argument of type 
                        <type>Key</type> and returns a value of type std::size_t.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Pred</emphasis>
                      </entry>
                      <entry>A binary function object that implements an equivalence relation on values of type 
                        <type>Key</type>. A binary function object that induces an equivalence relation on values of type Key. It takes two arguments of type Key and returns a value of type bool.
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <emphasis>Alloc</emphasis>
                      </entry>
                      <entry>An allocator whose value type is the same as the container's value type.
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </para>
            <para>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.
            </para>
            <para>The number of buckets is automatically increased whenever an insert will make the load factor greater than the maximum load factor. It can also change as result of calling rehash.
            </para>
            <para>When the number of buckets change: iterators are invalidated, the elements can change order, and move to different buckets, but pointers and references to elements remain valid.
            </para>
          </description>
          <typedef name="key_type">
            <type>Key</type>
          </typedef>
          <typedef name="value_type">
            <type>std::pair&lt;Key const, Value&gt;</type>
          </typedef>
          <typedef name="mapped_type">
            <type>T</type>
          </typedef>
          <typedef name="hasher">
            <type>Hash</type>
          </typedef>
          <typedef name="key_equal">
            <type>Pred</type>
          </typedef>
          <typedef name="allocator_type">
            <type>Alloc</type>
          </typedef>
          <typedef name="pointer">
            <type>typename allocator_type::pointer</type>
          </typedef>
          <typedef name="const_pointer">
            <type>typename allocator_type::const_pointer</type>
          </typedef>
          <typedef name="reference">
            <type>typename allocator_type::reference</type>
            <description>
              <para>lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="const_reference">
            <type>typename allocator_type::const_reference</type>
            <description>
              <para>const lvalue of 
                <type>value_type</type>.
              </para>
            </description>
          </typedef>
          <typedef name="size_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>unsigned integral type
              <notes>
                <type>size_type</type> can represent any non-negative value of 
                <type>difference_type</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="difference_type">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>signed integral type
              <notes>Is identical to the difference type of 
                <type>iterator</type> and 
                <type>const_iterator</type>.
              </notes>
            </description>
          </typedef>
          <typedef name="iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>
              <para>A iterator whose value type is 
                <type>value_type</type>.
              </para>
              <notes>
                <para>Any iterator category except output iterator.
                </para>
                <para>Convertible to 
                  <type>const_iterator</type>.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="const_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator whose value type is 
              <type>value_type</type>.
              <notes>
                <para>Any iterator category except output iterator.
                </para>
              </notes>
            </description>
          </typedef>
          <typedef name="local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>An iterator with the same value type, difference type and pointer and reference type as 
              <type>iterator</type>.
            </description>
            <description>A local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <typedef name="const_local_iterator">
            <type><emphasis>implementation-defined</emphasis></type>
            <description>A constant iterator with the same value type, difference type and pointer and reference type as 
              <type>const_iterator</type>.
            </description>
            <description>A const_local_iterator object can be used to iterate through a single bucket.
            </description>
          </typedef>
          <constructor>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <postconditions>
              <code><code><methodname>size</methodname>()</code> == 0</code>
            </postconditions>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocatorand a maximum load factor of 1.0.
              </para>
            </description>
          </constructor>
          <constructor>
            <template>
              <template-type-parameter name="InputIterator">
              </template-type-parameter>
            </template>
            <parameter name="f">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="l">
              <paramtype>InputIterator</paramtype>
            </parameter>
            <parameter name="n">
              <paramtype>size_type</paramtype>
              <default><code><emphasis>implementation-defined</emphasis></code></default>
            </parameter>
            <parameter name="hf">
              <paramtype><type>hasher</type> const&amp;</paramtype>
              <default><code>hasher()</code></default>
            </parameter>
            <parameter name="eq">
              <paramtype><type>key_equal</type> const&amp;</paramtype>
              <default><code>key_equal()</code></default>
            </parameter>
            <parameter name="a">
              <paramtype><type>allocator_type</type> const&amp;</paramtype>
              <default><code>allocator_type()</code></default>
            </parameter>
            <description>
              <para>Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1.0 and inserts the elements from [f, l) into it.
              </para>
            </description>
          </constructor>
          <constructor>
            <parameter>
              <paramtype><type>unordered_multimap</type> const&amp;</paramtype>
            </parameter>
            <description>
              <para>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.
              </para>
            </description>
          </constructor>
          <destructor>
          </destructor>
          <method name="operator=">
            <parameter>
              <paramtype><type>unordered_multimap</type> const&amp;</paramtype>
            </parameter>
            <type><type>unordered_multimap</type>&amp;</type>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.
          </method>
          <method name="get_allocator" cv="const">
            <type>allocator_type</type>
          </method>
          <method-group name="size and capacity">
            <method name="empty" cv="const">
              <type>bool</type>
              <returns>
                <code><code><methodname>size</methodname>()</code> == 0</code>
              </returns>
            </method>
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="max_size" cv="const">
              <type>size_type</type>
              <returns>
                <code><methodname>size</methodname>()</code> of the largest possible container.
              </returns>
            </method>
          </method-group>
          <method-group name="iterators">
            <overloaded-method name="begin">
              <signature><type>iterator</type></signature>
              <signature cv="const"><type>const_iterator</type></signature>
              <returns>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <type>const_iterator</type>
              </signature>
              <returns>An iterator which refers to the past-the-end value for the container.
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="modifiers">
            <method name="size" cv="const">
              <type>size_type</type>
              <returns>
                <code>std::distance(<code><methodname>begin</methodname>()</code>, <code><methodname>end</methodname>()</code>)</code>
              </returns>
            </method>
            <method name="insert">
              <parameter name="obj">
                <paramtype><type>value_type</type> const&amp;</paramtype>
              </parameter>
              <type>iterator</type>
              <description>
                <para>Inserts obj in the container.
                </para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="insert">
              <signature>
                <parameter name="hint">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="hint">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="obj">
                  <paramtype><type>value_type</type> const&amp;</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Inserts obj in the container.
                </para>
                <para>hint is a suggestion to where the element should be inserted.
                </para>
              </description>
              <returns>
                <para>An iterator pointing to the inserted element.
                </para>
              </returns>
              <throws>
                <para>If an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key. 
                </para>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </overloaded-method>
            <method name="insert">
              <template>
                <template-type-parameter name="InputIterator">
                </template-type-parameter>
              </template>
              <parameter name="first">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <parameter name="last">
                <paramtype>InputIterator</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Inserts a range of elements into the container. 
                </para>
              </description>
              <throws>
                <para>When inserting a single element, if an exception is thrown by an operation other than a call to 
                  <type>hasher</type> the function has no effect.
                </para>
              </throws>
              <notes>
                <para>Will only rehash if the insert causes the load factor to be greater to or equal to the maximum load factor.
                </para>
              </notes>
            </method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="position">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="position">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <description>
                <para>Erase the element pointed to by 
                  <code>position</code>.
                </para>
              </description>
              <returns>
                <para>The iterator following 
                  <code>position</code> before the erasure.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>size_type</type>
              </signature>
              <description>
                <para>Erase all elements with key equivalent to 
                  <code>k</code>.
                </para>
              </description>
              <returns>
                <para>The number of elements erased.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
              </throws>
            </overloaded-method>
            <overloaded-method name="erase">
              <signature>
                <parameter name="first">
                  <paramtype>iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>iterator</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature>
                <parameter name="first">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <parameter name="last">
                  <paramtype>const_iterator</paramtype>
                </parameter>
                <type>const_iterator</type>
              </signature>
              <descritpion>
                <para>Erases the elements in the range from 
                  <code>first</code> to 
                  <code>last</code>.
                </para>
              </descritpion>
              <returns>
                <para>The iterator following the erased elements - i.e. 
                  <code>last</code>.
                </para>
              </returns>
              <throws>
                <para>Only throws an exception, if it is thrown by a call to 
                  <type>hasher</type> or 
                  <type>key_equal</type>.
                </para>
                <para>They don't get called by the current implementation Boost.Unordered but other implementations may call them.
                </para>
              </throws>
            </overloaded-method>
            <method name="clear">
              <type>void</type>
              <description>
                <para>Erases all elements in the container.
                </para>
              </description>
              <postconditions>
                <para>
                  <code><code><methodname>size</methodname>()</code> == 0</code>
                </para>
              </postconditions>
              <throws>
                <para>Never throws an exception.
                </para>
              </throws>
            </method>
            <method name="swap">
              <parameter>
                <paramtype><type>unordered_multimap</type>&amp;</paramtype>
              </parameter>
              <type>void</type>
              <throws>
                <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
                  <type>key_equal</type> or 
                  <type>hasher</type>.
                </para>
              </throws>
            </method>
          </method-group>
          <method-group name="observers">
            <method name="hash_function" cv="const">
              <type>hasher</type>
              <returns>The container's hash function.
              </returns>
            </method>
            <method name="key_eq" cv="const">
              <type>key_equal</type>
              <returns>The container's key equality predicate.
              </returns>
            </method>
          </method-group>
          <method-group name="lookup">
            <overloaded-method name="find">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>iterator</type>
              </signature>
              <returns>
                <para>An iterator pointing to an element with key equivalent to 
                  <code>k</code>, or 
                  <code>b.end()</code> if no such element exists.
                </para>
              </returns>
            </overloaded-method>
            <method name="count" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The number of elements with key equivalent to 
                  <code>k</code>.
                </para>
              </returns>
            </method>
            <overloaded-method name="equal_range">
              <signature>
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <signature cv="const">
                <parameter name="k">
                  <paramtype><type>key_type</type> const&amp;</paramtype>
                </parameter>
                <type>std::pair&lt;iterator, iterator&gt;</type>
              </signature>
              <returns>
                <para>A range with containing all elements with key equivalent to 
                  <code>k</code>. If the container doesn't container any such elements, returns 
                  <code><functionname>std::make_pair</functionname>(<methodname>b.end</methodname>(),<methodname>b.end</methodname>())</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="bucket interface">
            <method name="bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>The number of buckets.
                </para>
              </returns>
            </method>
            <method name="max_bucket_count" cv="const">
              <type>size_type</type>
              <returns>
                <para>An upper bound on the number of buckets.
                </para>
              </returns>
            </method>
            <method name="bucket_size" cv="const">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>size_type</type>
              <requires>
                <para>
                  <code>n &lt; <methodname>bucket_count</methodname>()</code>
                </para>
              </requires>
            </method>
            <method name="bucket" cv="const">
              <parameter name="k">
                <paramtype><type>key_type</type> const&amp;</paramtype>
              </parameter>
              <type>size_type</type>
              <returns>
                <para>The index of the bucket which would contain an element with key 
                  <code>k</code>.
                </para>
              </returns>
              <postconditions>
                <para>The return value is less than 
                  <code>bucket_count()</code>
                </para>
              </postconditions>
            </method>
            <overloaded-method name="begin">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the first element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
            <overloaded-method name="end">
              <signature>
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>local_iterator</type>
              </signature>
              <signature cv="const">
                <parameter name="n">
                  <paramtype>size_type</paramtype>
                </parameter>
                <type>const_local_iterator</type>
              </signature>
              <requires>
                <para>
                  <code>n</code> shall be in the range 
                  <code>[0, bucket_count())</code>.
                </para>
              </requires>
              <returns>
                <para>A local iterator pointing the 'one past the end' element in the bucket with index 
                  <code>n</code>.
                </para>
              </returns>
            </overloaded-method>
          </method-group>
          <method-group name="hash policy">
            <method name="load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>The average number of elements per bucket.
                </para>
              </returns>
            </method>
            <method name="max_load_factor" cv="const">
              <type>float</type>
              <returns>
                <para>Returns the current maximum load factor.
                </para>
              </returns>
            </method>
            <method name="max_load_factor">
              <parameter name="z">
                <paramtype>float</paramtype>
              </parameter>
              <type>float</type>
              <returns>
                <para>Changes the container's maximum load factor,using 
                  <code>z</code> as a hint.
                </para>
              </returns>
            </method>
            <method name="rehash">
              <parameter name="n">
                <paramtype>size_type</paramtype>
              </parameter>
              <type>void</type>
              <description>
                <para>Changes the number of buckets so that there at least 
                  <code>n</code> buckets, and so that the load factor is less thanthe maximum load factor.
                </para>
                <para>Invalidates iterators, and changes the order of elements
                </para>
              </description>
              <throws>
                <para>The function has no effect if an exception is throw, unless it is thrown by the containerâ€™s hash function or comparison function.
                </para>
              </throws>
            </method>
          </method-group>
        </class>
        <function name="swap">
          <template>
            <template-type-parameter name="Key">
            </template-type-parameter>
            <template-type-parameter name="T">
            </template-type-parameter>
            <template-type-parameter name="Hash">
            </template-type-parameter>
            <template-type-parameter name="Pred">
            </template-type-parameter>
            <template-type-parameter name="Alloc">
            </template-type-parameter>
          </template>
          <parameter name="x">
            <paramtype><type>unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <parameter name="y">
            <paramtype><type>unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;</type>&amp;</paramtype>
          </parameter>
          <type>void</type>
          <effects>
            <para><code>x.swap(y)</code>
            </para>
          </effects>
          <throws>
            <para>Doesn't throw an exception unless it is thrown by the copy constructor or copy assignment operator of 
              <code>Hash</code> or 
              <code>Pred</code>.
            </para>
          </throws>
        </function>
      </namespace>
    </header>
  </section>
</library-reference>
